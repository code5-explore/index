<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MyDashboardBuilder</title>
    <style>
        body {
            font-family: sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            color: #333;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        .container {
            max-width: 1200px;
            margin: 20px auto;
            background-color: #fff;
            padding: 20px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
        }
        h1 {
            text-align: center;
            color: #0056b3;
            margin-bottom: 20px;
        }
        .upload-section {
            margin-bottom: 30px;
            text-align: center;
            border-bottom: 1px solid #eee;
            padding-bottom: 20px;
        }
        input[type="file"] {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin-right: 10px;
            cursor: pointer;
        }
        button {
            background-color: #007bff;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        button:hover {
            background-color: #0056b3;
        }
        .dashboard-area {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        .widget {
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            flex: 1 1 calc(50% - 20px);
            min-width: 300px;
        }
        .widget-full {
            flex: 1 1 100%;
        }
        h2 {
            margin-top: 0;
            color: #007bff;
            font-size: 1.2em;
        }
        .pivot-table-container, .chart-container {
            overflow-x: auto;
            max-height: 400px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        th, td {
            border: 1px solid #eee;
            padding: 8px;
            text-align: left;
            white-space: nowrap;
        }
        th {
            background-color: #e9e9e9;
            font-weight: bold;
        }
        .chart-options {
            margin-top: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }
        .chart-options label {
            margin-right: 5px;
        }
        .chart-options select {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }
        canvas {
            max-width: 100%;
            height: auto;
            display: block;
            margin-top: 15px;
        }
        @media (max-width: 768px) {
            .widget {
                flex: 1 1 100%;
            }
            .chart-options {
                flex-direction: column;
                align-items: flex-start;
            }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <div class="container">
        <h1>MyDashboardBuilder</h1>

        <div class="upload-section">
            <input type="file" id="fileInput" accept=".csv, .xls, .xlsx">
            <button onclick="handleFileUpload()">Upload File</button>
        </div>

        <div class="dashboard-area" id="dashboardArea">
            <div class="widget widget-full" id="dataPreviewWidget" style="display:none;">
                <h2>Data Preview</h2>
                <div class="pivot-table-container" id="dataPreviewTable"></div>
            </div>

            <div class="widget" id="pivotWidget" style="display:none;">
                <h2>Pivot Analysis</h2>
                <div class="pivot-options">
                    <label for="pivotRow">Rows:</label>
                    <select id="pivotRow"></select>
                    <label for="pivotCol">Columns:</label>
                    <select id="pivotCol"></select>
                    <label for="pivotValue">Values:</label>
                    <select id="pivotValue"></select>
                    <button onclick="performPivot()">Generate Pivot</button>
                </div>
                <div class="pivot-table-container" id="pivotTable"></div>
            </div>

            <div class="widget" id="chartWidget" style="display:none;">
                <h2>Data Visualization</h2>
                <div class="chart-options">
                    <label for="chartType">Chart Type:</label>
                    <select id="chartType" onchange="updateChartOptions()">
                        <option value="bar">Bar Chart</option>
                        <option value="line">Line Chart</option>
                        <option value="pie">Pie Chart</option>
                        <option value="histogram">Histogram</option>
                    </select>
                    <label for="chartXAxis">X-axis:</label>
                    <select id="chartXAxis"></select>
                    <label for="chartYAxis">Y-axis:</label>
                    <select id="chartYAxis"></select>
                    <label for="chartSlice" style="display:none;">Slice By:</label>
                    <select id="chartSlice" style="display:none;"></select>
                    <button onclick="generateChart()">Generate Chart</button>
                </div>
                <canvas id="myChart"></canvas>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('contextmenu', event => event.preventDefault());
        document.addEventListener('keydown', e => {
            if (e.ctrlKey && (e.key === 'u' || e.key === 'U')) {
                e.preventDefault();
            }
        });

        let currentData = [];
        let headers = [];
        let myChartInstance;

        async function handleFileUpload() {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];

            if (!file) {
                alert('Please select a file to upload.');
                return;
            }

            const fileName = file.name;
            const fileExtension = fileName.split('.').pop().toLowerCase();

            try {
                if (fileExtension === 'csv') {
                    await parseCSV(file);
                } else if (fileExtension === 'xls' || fileExtension === 'xlsx') {
                    alert('Excel file parsing not fully implemented in this single-file example. Please upload a CSV.');
                    return;
                } else {
                    alert('Unsupported file type. Please upload a CSV, XLS, or XLSX file.');
                    return;
                }
                displayDataPreview();
                populateSelects();
                document.getElementById('dataPreviewWidget').style.display = 'block';
                document.getElementById('pivotWidget').style.display = 'block';
                document.getElementById('chartWidget').style.display = 'block';

            } catch (error) {
                console.error('Error handling file upload:', error);
                alert('Error processing file. Please ensure it is a valid CSV/Excel format.');
            }
        }

        function parseCSV(file) {
            return new Promise((resolve, reject) => {
                Papa.parse(file, {
                    header: true,
                    dynamicTyping: true,
                    skipEmptyLines: true,
                    complete: function(results) {
                        if (results.data.length > 0) {
                            headers = Object.keys(results.data[0]);
                            currentData = results.data;
                            resolve();
                        } else {
                            reject(new Error("No data found in CSV."));
                        }
                    },
                    error: function(err) {
                        reject(err);
                    }
                });
            });
        }

        function displayDataPreview() {
            const previewTableDiv = document.getElementById('dataPreviewTable');
            previewTableDiv.innerHTML = '';
            if (currentData.length === 0) {
                previewTableDiv.textContent = 'No data to display.';
                return;
            }

            const table = document.createElement('table');
            const thead = document.createElement('thead');
            const tbody = document.createElement('tbody');

            const headerRow = document.createElement('tr');
            headers.forEach(header => {
                const th = document.createElement('th');
                th.textContent = header;
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);
            table.appendChild(thead);

            currentData.slice(0, 100).forEach(row => {
                const tr = document.createElement('tr');
                headers.forEach(header => {
                    const td = document.createElement('td');
                    td.textContent = row[header] !== undefined ? row[header] : '';
                    tr.appendChild(td);
                });
                tbody.appendChild(tr);
            });
            table.appendChild(tbody);
            previewTableDiv.appendChild(table);
        }

        function populateSelects() {
            const selects = ['pivotRow', 'pivotCol', 'pivotValue', 'chartXAxis', 'chartYAxis', 'chartSlice'];
            selects.forEach(id => {
                const select = document.getElementById(id);
                select.innerHTML = '<option value="">--Select--</option>';
                headers.forEach(header => {
                    const option = document.createElement('option');
                    option.value = header;
                    option.textContent = header;
                    select.appendChild(option);
                });
            });
        }

        function performPivot() {
            const rowField = document.getElementById('pivotRow').value;
            const colField = document.getElementById('pivotCol').value;
            const valueField = document.getElementById('pivotValue').value;

            if (!rowField || !valueField) {
                alert('Please select a Row and Value field for pivot analysis.');
                return;
            }

            const pivotTableDiv = document.getElementById('pivotTable');
            pivotTableDiv.innerHTML = '';

            const pivotData = {};
            const rowHeaders = new Set();
            const colHeaders = new Set();

            currentData.forEach(row => {
                const rVal = row[rowField];
                const cVal = colField ? row[colField] : '_TOTAL';
                const vVal = typeof row[valueField] === 'number' ? row[valueField] : parseFloat(row[valueField]);

                if (rVal !== undefined && vVal !== undefined && !isNaN(vVal)) {
                    rowHeaders.add(rVal);
                    colHeaders.add(cVal);

                    if (!pivotData[rVal]) {
                        pivotData[rVal] = {};
                    }
                    if (!pivotData[rVal][cVal]) {
                        pivotData[rVal][cVal] = 0;
                    }
                    pivotData[rVal][cVal] += vVal;
                }
            });

            const sortedRowHeaders = Array.from(rowHeaders).sort();
            const sortedColHeaders = Array.from(colHeaders).sort((a, b) => {
                if (a === '_TOTAL') return 1;
                if (b === '_TOTAL') return -1;
                return String(a).localeCompare(String(b));
            });

            const table = document.createElement('table');
            const thead = document.createElement('thead');
            const tbody = document.createElement('tbody');

            const headerRow = document.createElement('tr');
            headerRow.innerHTML = `<th>${rowField}</th>`;
            sortedColHeaders.forEach(col => {
                const th = document.createElement('th');
                th.textContent = col === '_TOTAL' ? 'Total' : col;
                headerRow.appendChild(th);
            });
            const totalColHeader = document.createElement('th');
            totalColHeader.textContent = 'Row Total';
            headerRow.appendChild(totalColHeader);
            thead.appendChild(headerRow);
            table.appendChild(thead);

            let grandTotal = 0;
            sortedRowHeaders.forEach(rVal => {
                const tr = document.createElement('tr');
                const th = document.createElement('th');
                th.textContent = rVal;
                tr.appendChild(th);

                let rowTotal = 0;
                sortedColHeaders.forEach(cVal => {
                    const td = document.createElement('td');
                    const value = pivotData[rVal] && pivotData[rVal][cVal] !== undefined ? pivotData[rVal][cVal].toFixed(2) : '0.00';
                    td.textContent = value;
                    rowTotal += parseFloat(value);
                    tr.appendChild(td);
                });
                const rowTotalTd = document.createElement('td');
                rowTotalTd.textContent = rowTotal.toFixed(2);
                tr.appendChild(rowTotalTd);
                tbody.appendChild(tr);
                grandTotal += rowTotal;
            });

            const footerRow = document.createElement('tr');
            const footerTh = document.createElement('th');
            footerTh.textContent = 'Column Total';
            footerRow.appendChild(footerTh);

            sortedColHeaders.forEach(cVal => {
                let colTotal = 0;
                sortedRowHeaders.forEach(rVal => {
                    const value = pivotData[rVal] && pivotData[rVal][cVal] !== undefined ? pivotData[rVal][cVal] : 0;
                    colTotal += value;
                });
                const td = document.createElement('td');
                td.textContent = colTotal.toFixed(2);
                footerRow.appendChild(td);
            });
            const grandTotalTd = document.createElement('td');
            grandTotalTd.textContent = grandTotal.toFixed(2);
            footerRow.appendChild(grandTotalTd);
            tbody.appendChild(footerRow);

            table.appendChild(tbody);
            pivotTableDiv.appendChild(table);
        }

        function updateChartOptions() {
            const chartType = document.getElementById('chartType').value;
            const sliceLabel = document.querySelector('label[for="chartSlice"]');
            const sliceSelect = document.getElementById('chartSlice');

            if (chartType === 'pie' || chartType === 'histogram') {
                document.querySelector('label[for="chartYAxis"]').style.display = 'none';
                document.getElementById('chartYAxis').style.display = 'none';
            } else {
                document.querySelector('label[for="chartYAxis"]').style.display = 'inline-block';
                document.getElementById('chartYAxis').style.display = 'inline-block';
            }

            if (chartType === 'histogram') {
                document.querySelector('label[for="chartXAxis"]').textContent = 'Data Column:';
            } else {
                document.querySelector('label[for="chartXAxis"]').textContent = 'X-axis:';
            }

            if (chartType === 'pie') {
                sliceLabel.style.display = 'inline-block';
                sliceSelect.style.display = 'inline-block';
                document.querySelector('label[for="chartXAxis"]').textContent = 'Category:';
                document.getElementById('chartXAxis').value = '';
                document.getElementById('chartYAxis').value = '';
            } else {
                sliceLabel.style.display = 'none';
                sliceSelect.style.display = 'none';
            }
        }

        function generateChart() {
            if (myChartInstance) {
                myChartInstance.destroy();
            }

            const chartType = document.getElementById('chartType').value;
            const xAxisField = document.getElementById('chartXAxis').value;
            const yAxisField = document.getElementById('chartYAxis').value;
            const sliceField = document.getElementById('chartSlice').value;

            const canvas = document.getElementById('myChart');
            const ctx = canvas.getContext('2d');

            let chartConfig;

            if (chartType === 'histogram') {
                if (!xAxisField) {
                    alert('Please select a Data Column for the histogram.');
                    return;
                }
                const dataValues = currentData.map(row => parseFloat(row[xAxisField])).filter(val => !isNaN(val));
                if (dataValues.length === 0) {
                    alert('No numeric data found for histogram.');
                    return;
                }

                const numBins = 10;
                const minVal = Math.min(...dataValues);
                const maxVal = Math.max(...dataValues);
                const binWidth = (maxVal - minVal) / numBins;

                if (binWidth === 0) {
                    chartConfig = {
                        type: 'bar',
                        data: {
                            labels: [`${minVal.toFixed(2)}`],
                            datasets: [{
                                label: `Frequency of ${xAxisField}`,
                                data: [dataValues.length],
                                backgroundColor: 'rgba(75, 192, 192, 0.6)',
                                borderColor: 'rgba(75, 192, 192, 1)',
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: true,
                            plugins: {
                                title: { display: true, text: `Histogram of ${xAxisField}` }
                            },
                            scales: {
                                x: { title: { display: true, text: 'Value' } },
                                y: { beginAtZero: true, title: { display: true, text: 'Frequency' } }
                            }
                        }
                    };
                } else {
                    const bins = Array(numBins).fill(0);
                    const labels = [];

                    for (let i = 0; i < numBins; i++) {
                        const lowerBound = minVal + i * binWidth;
                        const upperBound = minVal + (i + 1) * binWidth;
                        labels.push(`${lowerBound.toFixed(2)}-${upperBound.toFixed(2)}`);
                    }

                    dataValues.forEach(value => {
                        let binIndex = Math.floor((value - minVal) / binWidth);
                        if (binIndex === numBins) binIndex = numBins - 1;
                        if (binIndex >= 0 && binIndex < numBins) {
                            bins[binIndex]++;
                        }
                    });

                    chartConfig = {
                        type: 'bar',
                        data: {
                            labels: labels,
            color: #007bff;
            text-align: center;
        }
        .upload-section {
            padding: 20px;
            border: 1px dashed #ccc;
            margin-top: 20px;
            text-align: center;
        }
        input[type="file"] {
            margin-top: 10px;
        }
        button {
            background-color: #28a745;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 10px;
        }
        button:hover {
            background-color: #218838;
        }
        .dashboard {
            margin-top: 30px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        .widget {
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            box-shadow: 0 1px 5px rgba(0,0,0,0.05);
        }
        .widget h3 {
            margin-top: 0;
            color: #007bff;
            text-align: center;
        }
        .pivot-table-container, .chart-container {
            overflow-x: auto;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
            font-weight: bold;
        }
        select, input[type="number"] {
            padding: 8px;
            margin: 5px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }
        .controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
        }
        @media (max-width: 768px) {
            .container {
                margin: 10px;
                padding: 10px;
            }
            .dashboard {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>MyDashboardBuilder</h1>
    </header>
    <div class="container">
        <div class="upload-section">
            <h2>Upload Your Data</h2>
            <input type="file" id="fileInput" accept=".csv, .xlsx, .xls">
            <button onclick="handleFileUpload()">Load Data</button>
        </div>

        <div id="dataAnalysisSection" style="display: none;">
            <h2>Data Analysis & Visualization</h2>
            <div class="controls">
                <select id="chartType" onchange="updateVisualization()">
                    <option value="bar">Bar Chart</option>
                    <option value="line">Line Graph</option>
                    <option value="pie">Pie Chart</option>
                    <option value="histogram">Histogram</option>
                </select>
                <select id="xAxis" onchange="updateVisualization()"></select>
                <select id="yAxis" onchange="updateVisualization()"></select>
                <select id="pivotRow" onchange="updatePivotTable()"></select>
                <select id="pivotCol" onchange="updatePivotTable()"></select>
                <select id="pivotVal" onchange="updatePivotTable()"></select>
                <button onclick="updatePivotTable()">Generate Pivot</button>
            </div>

            <div class="dashboard">
                <div class="widget">
                    <h3>Pivot Table</h3>
                    <div class="pivot-table-container" id="pivotTableContainer"></div>
                </div>
                <div class="widget">
                    <h3>Data Visualization</h3>
                    <div class="chart-container">
                        <canvas id="myChart"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://unpkg.com/xlsx/dist/xlsx.full.min.js"></script>

    <script>
        let rawData = [];
        let headers = [];
        let myChart = null;

        document.addEventListener('contextmenu', event => event.preventDefault());
        document.addEventListener('keydown', event => {
            if (event.ctrlKey && (event.key === 'u' || event.key === 'U')) {
                event.preventDefault();
            }
        });

        async function handleFileUpload() {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];

            if (!file) {
                alert('Please select a file first.');
                return;
            }

            const fileExtension = file.name.split('.').pop().toLowerCase();

            if (fileExtension === 'csv') {
                PapaParse.parse(file, {
                    header: true,
                    skipEmptyLines: true,
                    complete: function(results) {
                        rawData = results.data;
                        headers = results.meta.fields;
                        initializeDashboard();
                    },
                    error: function(err) {
                        alert('Error parsing CSV file: ' + err.message);
                    }
                });
            } else if (fileExtension === 'xlsx' || fileExtension === 'xls') {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, {type: 'array'});
                    const sheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[sheetName];
                    rawData = XLSX.utils.sheet_to_json(worksheet, {header: 1});

                    if (rawData.length > 0) {
                        headers = rawData[0];
                        rawData = rawData.slice(1).map(row => {
                            let obj = {};
                            headers.forEach((header, i) => {
                                obj[header] = row[i];
                            });
                            return obj;
                        });
                        initializeDashboard();
                    } else {
                        alert('No data found in the Excel file.');
                    }
                };
                reader.onerror = function(ex) {
                    alert('Error reading Excel file: ' + ex);
                };
                reader.readAsArrayBuffer(file);
            } else {
                alert('Unsupported file type. Please upload a CSV or Excel file.');
            }
        }

        function initializeDashboard() {
            document.getElementById('dataAnalysisSection').style.display = 'block';
            populateSelects();
            updateVisualization();
            updatePivotTable();
        }

        function populateSelects() {
            const xAxisSelect = document.getElementById('xAxis');
            const yAxisSelect = document.getElementById('yAxis');
            const pivotRowSelect = document.getElementById('pivotRow');
            const pivotColSelect = document.getElementById('pivotCol');
            const pivotValSelect = document.getElementById('pivotVal');

            [xAxisSelect, yAxisSelect, pivotRowSelect, pivotColSelect, pivotValSelect].forEach(select => {
                select.innerHTML = '<option value="">-- Select --</option>';
            });

            headers.forEach(header => {
                const option = document.createElement('option');
                option.value = header;
                option.textContent = header;
                xAxisSelect.appendChild(option.cloneNode(true));
                yAxisSelect.appendChild(option.cloneNode(true));
                pivotRowSelect.appendChild(option.cloneNode(true));
                pivotColSelect.appendChild(option.cloneNode(true));
                pivotValSelect.appendChild(option.cloneNode(true));
            });

            if (headers.length > 0) {
                xAxisSelect.value = headers[0];
                if (headers.length > 1) {
                    yAxisSelect.value = headers[1];
                }
                pivotRowSelect.value = headers[0];
                if (headers.length > 1) {
                    pivotColSelect.value = headers[1];
                }
                if (headers.length > 2) {
                    pivotValSelect.value = headers[2];
                } else if (headers.length > 0) {
                    pivotValSelect.value = headers[0];
                }
            }
        }

        function updateVisualization() {
            const chartType = document.getElementById('chartType').value;
            const xAxisCol = document.getElementById('xAxis').value;
            const yAxisCol = document.getElementById('yAxis').value;
            const ctx = document.getElementById('myChart').getContext('2d');

            if (myChart) {
                myChart.destroy();
            }

            if (!xAxisCol || !yAxisCol) {
                myChart = new Chart(ctx, {type: 'bar', data: {labels: [], datasets: []}});
                return;
            }

            const xLabels = rawData.map(row => row[xAxisCol]);
            const yValues = rawData.map(row => parseFloat(row[yAxisCol])).filter(val => !isNaN(val));

            let data = {};
            let options = {};

            switch (chartType) {
                case 'bar':
                case 'line':
                    data = {
                        labels: xLabels,
                        datasets: [{
                            label: yAxisCol,
                            data: yValues,
                            backgroundColor: chartType === 'bar' ? 'rgba(0, 123, 255, 0.5)' : 'rgba(0, 123, 255, 0.2)',
                            borderColor: 'rgba(0, 123, 255, 1)',
                            borderWidth: 1,
                            fill: chartType === 'line' ? true : false
                        }]
                    };
                    options = {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        }
                    };
                    break;
                case 'pie':
                    const counts = {};
                    xLabels.forEach(label => {
                        counts[label] = (counts[label] || 0) + 1;
                    });
                    const pieLabels = Object.keys(counts);
                    const pieData = Object.values(counts);
                    const backgroundColors = pieLabels.map((_, i) => `hsl(${i * 60}, 70%, 50%)`);

                    data = {
                        labels: pieLabels,
                        datasets: [{
                            data: pieData,
                            backgroundColor: backgroundColors,
                            hoverOffset: 4
                        }]
                    };
                    options = {
                        responsive: true,
                        maintainAspectRatio: false,
                    };
                    break;
                case 'histogram':
                    const numbers = rawData.map(row => parseFloat(row[yAxisCol])).filter(val => !isNaN(val));
                    if (numbers.length === 0) {
                        data = {labels: [], datasets: []};
                        break;
                    }
                    const min = Math.min(...numbers);
                    const max = Math.max(...numbers);
                    const numBins = 10;
                    const binWidth = (max - min) / numBins;

                    const bins = Array(numBins).fill(0);
                    const binLabels = [];
                    for (let i = 0; i < numBins; i++) {
                        binLabels.push(`${(min + i * binWidth).toFixed(2)}-${(min + (i + 1) * binWidth).toFixed(2)}`);
                    }

                    numbers.forEach(num => {
                        let binIndex = Math.floor((num - min) / binWidth);
                        if (binIndex >= numBins) binIndex = numBins - 1; // For max value
                        bins[binIndex]++;
                    });

                    data = {
                        labels: binLabels,
                        datasets: [{
                            label: `Frequency of ${yAxisCol}`,
                            data: bins,
                            backgroundColor: 'rgba(255, 159, 64, 0.5)',
                            borderColor: 'rgba(255, 159, 64, 1)',
                            borderWidth: 1
                        }]
                    };
                    options = {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        }
                    };
                    break;
            }

            myChart = new Chart(ctx, {
                type: chartType === 'line' || chartType === 'bar' || chartType === 'histogram' ? 'bar' : chartType,
                data: data,
                options: options
            });
        }

        function updatePivotTable() {
            const rowCol = document.getElementById('pivotRow').value;
            const colCol = document.getElementById('pivotCol').value;
            const valCol = document.getElementById('pivotVal').value;
            const pivotTableContainer = document.getElementById('pivotTableContainer');

            if (!rowCol || !colCol || !valCol) {
                pivotTableContainer.innerHTML = '<p style="text-align: center;">Select row, column, and value fields for pivot table.</p>';
                return;
            }

            const pivot = {};
            const uniqueCols = new Set();
            const uniqueRows = new Set();

            rawData.forEach(row => {
                const r = row[rowCol];
                const c = row[colCol];
                const v = parseFloat(row[valCol]);

                if (!isNaN(v)) {
                    if (!pivot[r]) {
                        pivot[r] = {};
                    }
                    if (!pivot[r][c]) {
                        pivot[r][c] = 0;
                    }
                    pivot[r][c] += v;
                    uniqueCols.add(c);
                    uniqueRows.add(r);
                }
            });

            const sortedUniqueCols = Array.from(uniqueCols).sort();
            const sortedUniqueRows = Array.from(uniqueRows).sort();

            let tableHTML = '<table><thead><tr><th>' + rowCol + ' \\ ' + colCol + '</th>';
            sortedUniqueCols.forEach(col => {
                tableHTML += '<th>' + col + '</th>';
            });
            tableHTML += '<th>Grand Total</th></tr></thead><tbody>';

            let grandColTotals = {};
            sortedUniqueCols.forEach(col => grandColTotals[col] = 0);
            let overallGrandTotal = 0;

            sortedUniqueRows.forEach(r => {
                tableHTML += '<tr><td>' + r + '</td>';
                let rowTotal = 0;
                sortedUniqueCols.forEach(c => {
                    const value = pivot[r] && pivot[r][c] ? pivot[r][c].toFixed(2) : '0.00';
                    tableHTML += '<td>' + value + '</td>';
                    rowTotal += parseFloat(value);
                    grandColTotals[c] += parseFloat(value);
                });
                tableHTML += '<td>' + rowTotal.toFixed(2) + '</td></tr>';
                overallGrandTotal += rowTotal;
            });

            tableHTML += '<tr><td><b>Grand Total</b></td>';
            sortedUniqueCols.forEach(col => {
                tableHTML += '<td><b>' + grandColTotals[col].toFixed(2) + '</b></td>';
            });
            tableHTML += '<td><b>' + overallGrandTotal.toFixed(2) + '</b></td></tr>';
            tableHTML += '</tbody></table>';

            pivotTableContainer.innerHTML = tableHTML;
        }
    </script>
</body>
</html>
```            margin: auto;
        }

        .upload-section, .analysis-section, .visualization-section, .export-section {
            background-color: #fff;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        input[type="file"] {
            display: block;
            margin-bottom: 10px;
        }

        button {
            background-color: #007bff;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }

        button:hover {
            background-color: #0056b3;
        }

        select, input[type="text"], input[type="number"] {
            padding: 8px;
            margin-right: 10px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }

        #data-preview {
            max-height: 300px;
            overflow: auto;
            border: 1px solid #ddd;
            margin-top: 15px;
            padding: 10px;
            background-color: #f9f9f9;
        }

        #data-preview table {
            width: 100%;
            border-collapse: collapse;
        }

        #data-preview th, #data-preview td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        #pivot-table {
            margin-top: 20px;
            border: 1px solid #ddd;
            padding: 10px;
            max-height: 400px;
            overflow: auto;
        }

        #pivot-table table {
            width: 100%;
            border-collapse: collapse;
        }

        #pivot-table th, #pivot-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        .chart-container {
            position: relative;
            height: 400px;
            width: 100%;
            margin-top: 20px;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            button, select, input[type="text"], input[type="number"] {
                width: 100%;
                margin-bottom: 10px;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>MyDashboardBuilder</h1>
    </header>

    <div class="container">
        <div class="upload-section">
            <h2>Upload Data</h2>
            <input type="file" id="file-input" accept=".csv, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel">
            <button onclick="processFile()">Upload & Process</button>
            <div id="data-preview"></div>
        </div>

        <div class="analysis-section">
            <h2>Pivot Analysis</h2>
            <div id="pivot-controls">
                Rows: <select id="pivot-rows"></select>
                Columns: <select id="pivot-columns"></select>
                Values: <select id="pivot-values"></select>
                Aggregate:
                <select id="pivot-aggregate">
                    <option value="sum">Sum</option>
                    <option value="count">Count</option>
                    <option value="avg">Average</option>
                    <option value="min">Min</option>
                    <option value="max">Max</option>
                </select>
                <button onclick="performPivot()">Perform Pivot</button>
            </div>
            <div id="pivot-table"></div>
        </div>

        <div class="visualization-section">
            <h2>Data Visualization</h2>
            <div id="chart-controls">
                Chart Type:
                <select id="chart-type">
                    <option value="bar">Bar Chart</option>
                    <option value="line">Line Chart</option>
                    <option value="pie">Pie Chart</option>
                    <option value="histogram">Histogram</option>
                </select>
                X-Axis: <select id="chart-x"></select>
                Y-Axis: <select id="chart-y"></select>
                Bins (for Histogram): <input type="number" id="histogram-bins" value="10" min="1">
                <button onclick="generateChart()">Generate Chart</button>
            </div>
            <div class="chart-container">
                <canvas id="myChart"></canvas>
            </div>
        </div>

        <div class="export-section">
            <h2>Export Results</h2>
            <button onclick="exportData()">Export Current Data</button>
            <button onclick="exportPivotTable()">Export Pivot Table</button>
            <button onclick="exportChart()">Export Chart as Image</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.17.0/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        document.addEventListener('contextmenu', event => event.preventDefault());
        document.addEventListener('keydown', e => {
            if (e.ctrlKey && (e.key === 'u' || e.key === 's' || e.key === 'p')) {
                e.preventDefault();
            }
        });

        let rawData = [];
        let headerRow = [];
        let myChartInstance;

        function processFile() {
            const fileInput = document.getElementById('file-input');
            const file = fileInput.files[0];

            if (!file) {
                alert('Please select a file first.');
                return;
            }

            const reader = new FileReader();

            reader.onload = function(e) {
                const data = e.target.result;
                if (file.name.endsWith('.csv')) {
                    PapaParse.parse(data, {
                        header: true,
                        skipEmptyLines: true,
                        complete: function(results) {
                            rawData = results.data;
                            if (rawData.length > 0) {
                                headerRow = Object.keys(rawData[0]);
                                displayDataPreview();
                                populateSelects();
                            } else {
                                alert('CSV file is empty or malformed.');
                            }
                        }
                    });
                } else if (file.name.endsWith('.xlsx') || file.name.endsWith('.xls')) {
                    const workbook = XLSX.read(data, { type: 'binary' });
                    const sheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[sheetName];
                    rawData = XLSX.utils.sheet_to_json(worksheet);
                    if (rawData.length > 0) {
                        headerRow = Object.keys(rawData[0]);
                        displayDataPreview();
                        populateSelects();
                    } else {
                        alert('Excel file is empty or malformed.');
                    }
                } else {
                    alert('Unsupported file type. Please upload a CSV or Excel file.');
                }
            };

            if (file.name.endsWith('.csv')) {
                reader.readAsText(file);
            } else if (file.name.endsWith('.xlsx') || file.name.endsWith('.xls')) {
                reader.readAsBinaryString(file);
            }
        }

        function displayDataPreview() {
            const previewDiv = document.getElementById('data-preview');
            previewDiv.innerHTML = '';

            if (rawData.length === 0) {
                previewDiv.innerHTML = '<p>No data to display.</p>';
                return;
            }

            let tableHTML = '<table><thead><tr>';
            headerRow.forEach(header => {
                tableHTML += `<th>${header}</th>`;
            });
            tableHTML += '</tr></thead><tbody>';

            for (let i = 0; i < Math.min(rawData.length, 10); i++) {
                tableHTML += '<tr>';
                headerRow.forEach(header => {
                    tableHTML += `<td>${rawData[i][header] || ''}</td>`;
                });
                tableHTML += '</tr>';
            }
            tableHTML += '</tbody></table>';
            previewDiv.innerHTML = tableHTML;
        }

        function populateSelects() {
            const pivotRowsSelect = document.getElementById('pivot-rows');
            const pivotColumnsSelect = document.getElementById('pivot-columns');
            const pivotValuesSelect = document.getElementById('pivot-values');
            const chartXSelect = document.getElementById('chart-x');
            const chartYSelect = document.getElementById('chart-y');

            [pivotRowsSelect, pivotColumnsSelect, pivotValuesSelect, chartXSelect, chartYSelect].forEach(select => {
                select.innerHTML = '<option value="">-- Select --</option>';
            });

            headerRow.forEach(header => {
                const option = `<option value="${header}">${header}</option>`;
                pivotRowsSelect.innerHTML += option;
                pivotColumnsSelect.innerHTML += option;
                pivotValuesSelect.innerHTML += option;
                chartXSelect.innerHTML += option;
                chartYSelect.innerHTML += option;
            });
        }

        function performPivot() {
            const rowsField = document.getElementById('pivot-rows').value;
            const columnsField = document.getElementById('pivot-columns').value;
            const valuesField = document.getElementById('pivot-values').value;
            const aggregateType = document.getElementById('pivot-aggregate').value;
            const pivotTableDiv = document.getElementById('pivot-table');
            pivotTableDiv.innerHTML = '';

            if (!rowsField || !valuesField) {
                pivotTableDiv.innerHTML = '<p>Please select at least a Rows and Values field for pivot analysis.</p>';
                return;
            }

            const pivotData = {};
            const rowHeaders = new Set();
            const colHeaders = new Set();

            rawData.forEach(row => {
                const rowKey = row[rowsField];
                const colKey = columnsField ? row[columnsField] : '_TOTAL_';
                const value = parseFloat(row[valuesField]);

                if (isNaN(value)) return;

                rowHeaders.add(rowKey);
                if (columnsField) colHeaders.add(colKey);

                if (!pivotData[rowKey]) {
                    pivotData[rowKey] = {};
                }
                if (!pivotData[rowKey][colKey]) {
                    pivotData[rowKey][colKey] = [];
                }
                pivotData[rowKey][colKey].push(value);
            });

            const sortedRowHeaders = Array.from(rowHeaders).sort();
            const sortedColHeaders = columnsField ? Array.from(colHeaders).sort() : ['_TOTAL_'];

            let tableHTML = '<table><thead><tr>';
            tableHTML += `<th>${rowsField}</th>`;
            sortedColHeaders.forEach(colHeader => {
                tableHTML += `<th>${colHeader === '_TOTAL_' ? valuesField : colHeader}</th>`;
            });
            tableHTML += `<th>Row Total (${aggregateType})</th>`;
            tableHTML += '</tr></thead><tbody>';

            const columnTotals = {};

            sortedRowHeaders.forEach(rowHeader => {
                tableHTML += '<tr>';
                tableHTML += `<td>${rowHeader}</td>`;
                let rowTotal = 0;
                let rowCount = 0;
                let rowMin = Infinity;
                let rowMax = -Infinity;
                let rowSum = 0;

                sortedColHeaders.forEach(colHeader => {
                    const values = pivotData[rowHeader] && pivotData[rowHeader][colHeader] ? pivotData[rowHeader][colHeader] : [];
                    let aggregatedValue = 0;

                    if (!columnTotals[colHeader]) {
                        columnTotals[colHeader] = { sum: 0, count: 0, min: Infinity, max: -Infinity, values: [] };
                    }

                    if (values.length > 0) {
                        const sum = values.reduce((a, b) => a + b, 0);
                        const count = values.length;
                        const min = Math.min(...values);
                        const max = Math.max(...values);

                        rowSum += sum;
                        rowCount += count;
                        rowMin = Math.min(rowMin, min);
                        rowMax = Math.max(rowMax, max);

                        columnTotals[colHeader].sum += sum;
                        columnTotals[colHeader].count += count;
                        columnTotals[colHeader].min = Math.min(columnTotals[colHeader].min, min);
                        columnTotals[colHeader].max = Math.max(columnTotals[colHeader].max, max);
                        columnTotals[colHeader].values.push(...values);

                        switch (aggregateType) {
                            case 'sum': aggregatedValue = sum; break;
                            case 'count': aggregatedValue = count; break;
                            case 'avg': aggregatedValue = (sum / count).toFixed(2); break;
                            case 'min': aggregatedValue = min; break;
                            case 'max': aggregatedValue = max; break;
                        }
                    }
                    tableHTML += `<td>${aggregatedValue}</td>`;
                });

                let finalRowTotal = 0;
                switch (aggregateType) {
                    case 'sum': finalRowTotal = rowSum; break;
                    case 'count': finalRowTotal = rowCount; break;
                    case 'avg': finalRowTotal = rowCount > 0 ? (rowSum / rowCount).toFixed(2) : 0; break;
                    case 'min': finalRowTotal = rowMin === Infinity ? 0 : rowMin; break;
                    case 'max': finalRowTotal = rowMax === -Infinity ? 0 : rowMax; break;
                }
                tableHTML += `<td>${finalRowTotal}</td>`;
                tableHTML += '</tr>';
            });

            tableHTML += '<tfoot><tr><th>Column Total (' + aggregateType + ')</th>';
            sortedColHeaders.forEach(colHeader => {
                let aggregatedColValue = 0;
                const colAggData = columnTotals[colHeader];
                if (colAggData && colAggData.count > 0) {
                    switch (aggregateType) {
                        case 'sum': aggregatedColValue = colAggData.sum; break;
                        case 'count': aggregatedColValue = colAggData.count; break;
                        case 'avg': aggregatedColValue = (colAggData.sum / colAggData.count).toFixed(2); break;
                        case 'min': aggregatedColValue = colAggData.min; break;
                        case 'max': aggregatedColValue = colAggData.max; break;
                    }
                }
                tableHTML += `<td>${aggregatedColValue}</td>`;
            });

            let grandTotal = 0;
            let grandCount = 0;
            let grandMin = Infinity;
            let grandMax = -Infinity;
            let grandSum = 0;
            Object.values(columnTotals).forEach(colAggData => {
                if(colAggData){
                     grandSum += colAggData.sum;
                     grandCount += colAggData.count;
                     grandMin = Math.min(grandMin, colAggData.min);
                     grandMax = Math.max(grandMax, colAggData.max);
                }
            });

            switch (aggregateType) {
                case 'sum': grandTotal = grandSum; break;
                case 'count': grandTotal = grandCount; break;
                case 'avg': grandTotal = grandCount > 0 ? (grandSum / grandCount).toFixed(2) : 0; break;
                case 'min': grandTotal = grandMin === Infinity ? 0 : grandMin; break;
                case 'max': grandTotal = grandMax === -Infinity ? 0 : grandMax; break;
            }
            tableHTML += `<td>${grandTotal}</td>`;
            tableHTML += '</tr></tfoot>';
            tableHTML += '</tbody></table>';
            pivotTableDiv.innerHTML = tableHTML;
        }

        function generateChart() {
            const chartType = document.getElementById('chart-type').value;
            const chartX = document.getElementById('chart-x').value;
            const chartY = document.getElementById('chart-y').value;
            const histogramBins = parseInt(document.getElementById('histogram-bins').value);

            const canvas = document.getElementById('myChart');

            if (myChartInstance) {
                myChartInstance.destroy();
            }

            if (!chartX && chartType !== 'pie') {
                alert('Please select an X-Axis field.');
                return;
            }
            if (!chartY && chartType !== 'pie' && chartType !== 'histogram') {
                alert('Please select a Y-Axis field.');
                return;
            }
            if ((!chartX && !chartY) && chartType === 'pie') {
                 alert('Please select at least one field for Pie chart.');
                 return;
            }

            let labels = [];
            let dataValues = [];
            let chartConfig = {};

            if (chartType === 'pie') {
                const pieField = chartX || chartY;
                if (!pieField) {
                    alert('Please select a field for the Pie chart.');
                    return;
                }
                const counts = {};
                rawData.forEach(row => {
                    const key = row[pieField];
                    counts[key] = (counts[key] || 0) + 1;
                });
                labels = Object.keys(counts);
                dataValues = Object.values(counts);

                chartConfig = {
                    type: chartType,
                    data: {
                        labels: labels,
                        datasets: [{
                            data: dataValues,
                            backgroundColor: labels.map(() => `hsl(${Math.random() * 360}, 70%, 50%)`)
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: `Pie Chart of ${pieField}`
                            }
                        }
                    }
                };
            } else if (chartType === 'histogram') {
                if (!chartX) {
                    alert('Please select an X-Axis field for the Histogram.');
        <script src="https://cdn.jsdelivr.net/npm/sheetjs-style/dist/xlsx.full.min.js"></script>
</head>
<body>
    <div class="container">
        <h1>MyDashboardBuilder</h1>

        <div class="upload-section">
            <p>Upload your Excel (.xlsx) or CSV (.csv) file</p>
            <input type="file" id="fileInput" accept=".csv, .xlsx">
        </div>

        <div id="dataView" class="hidden">
            <h2>Data Preview</h2>
            <div class="data-table-container">
                <table id="dataTable"></table>
            </div>

            <h2>Pivot Analysis</h2>
            <div class="pivot-controls">
                <label for="pivotRows">Rows:</label>
                <select id="pivotRows"></select>
                <label for="pivotCols">Columns:</label>
                <select id="pivotCols"></select>
                <label for="pivotValues">Values:</label>
                <select id="pivotValues"></select>
                <label for="pivotAgg">Aggregation:</label>
                <select id="pivotAgg">
                    <option value="sum">Sum</option>
                    <option value="count">Count</option>
                    <option value="avg">Average</option>
                    <option value="min">Min</option>
                    <option value="max">Max</option>
                </select>
                <button onclick="generatePivotTable()">Generate Pivot</button>
            </div>
            <div class="pivot-table-container">
                <table id="pivotTable"></table>
            </div>

            <h2>Data Visualizations</h2>
            <div class="chart-controls">
                <label for="chartType">Chart Type:</label>
                <select id="chartType">
                    <option value="bar">Bar Chart</option>
                    <option value="line">Line Chart</option>
                    <option value="pie">Pie Chart</option>
                    <option value="doughnut">Doughnut Chart</option>
                    <option value="histogram">Histogram (Bar)</option>
                </select>
                <label for="chartXAxis">X-Axis:</label>
                <select id="chartXAxis"></select>
                <label for="chartYAxis">Y-Axis (for bar/line/histogram):</label>
                <select id="chartYAxis"></select>
                <label for="chartSliceBy">Slice By (for pie/doughnut):</label>
                <select id="chartSliceBy"></select>
                <button onclick="generateChart()">Generate Chart</button>
            </div>
            <div class="chart-display">
                <canvas id="myChart"></canvas>
            </div>

            <div class="export-section">
                <button onclick="exportToExcel()">Export Results to Excel</button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('contextmenu', event => event.preventDefault());
        document.onkeydown = function(e) {
            if (e.keyCode == 123 || (e.ctrlKey && e.shiftKey && e.keyCode == 'I'.charCodeAt(0)) || (e.ctrlKey && e.shiftKey && e.keyCode == 'J'.charCodeAt(0)) || (e.ctrlKey && e.keyCode == 'U'.charCodeAt(0))) {
                return false;
            }
        };

        let rawData = [];
        let headers = [];
        let myChartInstance;

        document.getElementById('fileInput').addEventListener('change', handleFile, false);

        function handleFile(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(event) {
                const data = event.target.result;
                const fileName = file.name;

                if (fileName.endsWith('.csv')) {
                    parseCSV(data);
                } else if (fileName.endsWith('.xlsx')) {
                    parseExcel(data);
                }
            };

            if (file.name.endsWith('.csv')) {
                reader.readAsText(file);
            } else if (file.name.endsWith('.xlsx')) {
                reader.readAsArrayBuffer(file);
            }
        }

        function parseCSV(data) {
            PapaParse.parse(data, {
                header: true,
                skipEmptyLines: true,
                complete: function(results) {
                    rawData = results.data;
                    headers = results.meta.fields;
                    displayData();
                }
            });
        }

        function parseExcel(data) {
            const workbook = XLSX.read(data, { type: 'array' });
            const sheetName = workbook.SheetNames[0];
            const worksheet = workbook.Sheets[sheetName];
            rawData = XLSX.utils.sheet_to_json(worksheet);
            if (rawData.length > 0) {
                headers = Object.keys(rawData[0]);
            } else {
                headers = [];
            }
            displayData();
        }

        function displayData() {
            const dataView = document.getElementById('dataView');
            dataView.classList.remove('hidden');

            const dataTable = document.getElementById('dataTable');
            dataTable.innerHTML = '';

            let thead = dataTable.createTHead();
            let row = thead.insertRow();
            headers.forEach(header => {
                let th = document.createElement('th');
                th.textContent = header;
                row.appendChild(th);
            });

            let tbody = dataTable.createTBody();
            rawData.slice(0, 50).forEach(rowData => {
                let tr = tbody.insertRow();
                headers.forEach(header => {
                    let td = tr.insertCell();
                    td.textContent = rowData[header] !== undefined ? rowData[header] : '';
                });
            });

            populateDropdowns();
        }

        function populateDropdowns() {
            const selectElements = ['pivotRows', 'pivotCols', 'pivotValues', 'chartXAxis', 'chartYAxis', 'chartSliceBy'];
            selectElements.forEach(id => {
                const select = document.getElementById(id);
                select.innerHTML = '<option value="">--Select--</option>';
                headers.forEach(header => {
                    const option = document.createElement('option');
                    option.value = header;
                    option.textContent = header;
                    select.appendChild(option);
                });
            });
        }

        function generatePivotTable() {
            const rowsField = document.getElementById('pivotRows').value;
            const colsField = document.getElementById('pivotCols').value;
            const valuesField = document.getElementById('pivotValues').value;
            const aggType = document.getElementById('pivotAgg').value;

            if (!rowsField || !valuesField) {
                alert('Please select at least Rows and Values for pivot analysis.');
                return;
            }

            const pivotTable = {};
            const colHeaders = new Set();
            const rowHeaders = new Set();

            rawData.forEach(item => {
                const rowKey = item[rowsField];
                const colKey = colsField ? item[colsField] : 'Total';
                const value = parseFloat(item[valuesField]);

                if (isNaN(value)) return;

                rowHeaders.add(rowKey);
                colHeaders.add(colKey);

                if (!pivotTable[rowKey]) {
                    pivotTable[rowKey] = {};
                }
                if (!pivotTable[rowKey][colKey]) {
                    pivotTable[rowKey][colKey] = [];
                }
                pivotTable[rowKey][colKey].push(value);
            });

            const sortedRowHeaders = Array.from(rowHeaders).sort();
            const sortedColHeaders = Array.from(colHeaders).sort();

            const tableElement = document.getElementById('pivotTable');
            tableElement.innerHTML = '';

            let thead = tableElement.createTHead();
            let headRow = thead.insertRow();
            let cornerTh = document.createElement('th');
            cornerTh.textContent = rowsField + (colsField ? ' / ' + colsField : '');
            headRow.appendChild(cornerTh);
            sortedColHeaders.forEach(col => {
                let th = document.createElement('th');
                th.textContent = col;
                headRow.appendChild(th);
            });
            let totalColTh = document.createElement('th');
            totalColTh.textContent = 'Row Total';
            headRow.appendChild(totalColTh);


            let tbody = tableElement.createTBody();
            sortedRowHeaders.forEach(rowKey => {
                let tr = tbody.insertRow();
                let th = document.createElement('th');
                th.textContent = rowKey;
                tr.appendChild(th);

                let rowTotal = 0;
                sortedColHeaders.forEach(colKey => {
                    let td = tr.insertCell();
                    const values = (pivotTable[rowKey] && pivotTable[rowKey][colKey]) ? pivotTable[rowKey][colKey] : [];
                    let result;
                    if (values.length === 0) {
                        result = '';
                    } else {
                        switch (aggType) {
                            case 'sum': result = values.reduce((a, b) => a + b, 0); break;
                            case 'count': result = values.length; break;
                            case 'avg': result = values.reduce((a, b) => a + b, 0) / values.length; break;
                            case 'min': result = Math.min(...values); break;
                            case 'max': result = Math.max(...values); break;
                            default: result = '';
                        }
                        rowTotal += result;
                        result = result.toFixed(2);
                    }
                    td.textContent = result;
                });
                let totalTd = tr.insertCell();
                totalTd.textContent = rowTotal.toFixed(2);
            });

            let footer = tableElement.createTFoot();
            let footerRow = footer.insertRow();
            let footerTh = document.createElement('th');
            footerTh.textContent = 'Column Total';
            footerRow.appendChild(footerTh);

            let grandTotal = 0;
            sortedColHeaders.forEach(colKey => {
                let colTotal = 0;
                sortedRowHeaders.forEach(rowKey => {
                    const values = (pivotTable[rowKey] && pivotTable[rowKey][colKey]) ? pivotTable[rowKey][colKey] : [];
                    let result;
                    if (values.length > 0) {
                        switch (aggType) {
                            case 'sum': result = values.reduce((a, b) => a + b, 0); break;
                            case 'count': result = values.length; break;
                            case 'avg': result = values.reduce((a, b) => a + b, 0) / values.length; break;
                            case 'min': result = Math.min(...values); break;
                            case 'max': result = Math.max(...values); break;
                            default: result = 0;
                        }
                        colTotal += result;
                    }
                });
                let td = footerRow.insertCell();
                td.textContent = colTotal.toFixed(2);
                grandTotal += colTotal;
            });
            let grandTotalTd = footerRow.insertCell();
            grandTotalTd.textContent = grandTotal.toFixed(2);
        }

        function generateChart() {
            const chartType = document.getElementById('chartType').value;
            const xAxisField = document.getElementById('chartXAxis').value;
            const yAxisField = document.getElementById('chartYAxis').value;
            const sliceByField = document.getElementById('chartSliceBy').value;

            if ((chartType === 'bar' || chartType === 'line' || chartType === 'histogram') && (!xAxisField || !yAxisField)) {
                alert('Please select X-Axis and Y-Axis for bar, line or histogram charts.');
                return;
            }
            if ((chartType === 'pie' || chartType === 'doughnut') && !sliceByField) {
                alert('Please select Slice By field for pie or doughnut charts.');
                return;
            }

            let labels = [];
            let data = [];
            let backgroundColor = [];

            if (chartType === 'bar' || chartType === 'line') {
                const groupedData = {};
                rawData.forEach(item => {
                    const xVal = item[xAxisField];
                    const yVal = parseFloat(item[yAxisField]);
                    if (!isNaN(yVal)) {
                        if (!groupedData[xVal]) {
                            groupedData[xVal] = 0;
                        }
                        groupedData[xVal] += yVal;
                    }
                });
                labels = Object.keys(groupedData).sort();
                data = labels.map(label => groupedData[label]);
                backgroundColor = labels.map(() => `rgba(${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)}, 0.6)`);
            } else if (chartType === 'pie' || chartType === 'doughnut') {
                const groupedData = {};
                rawData.forEach(item => {
                    const sliceVal = item[sliceByField];
                    if (!groupedData[sliceVal]) {
                        groupedData[sliceVal] = 0;
                    }
                    groupedData[sliceVal]++;
                });
                labels = Object.keys(groupedData).sort();
                data = labels.map(label => groupedData[label]);
                backgroundColor = labels.map(() => `rgba(${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)}, 0.6)`);
            } else if (chartType === 'histogram') {
                const values = rawData.map(item => parseFloat(item[yAxisField])).filter(val => !isNaN(val));
                if (values.length === 0) {
                    alert('No numeric data for histogram.');
                    return;
                }

                const numBins = 10;
                const minVal = Math.min(...values);
                const maxVal = Math.max(...values);
                const range = maxVal - minVal;
                const binSize = range / numBins;

                const bins = Array(numBins).fill(0);
                labels = Array(numBins).fill(0).map((_, i) => `${(minVal + i * binSize).toFixed(2)} - ${(minVal + (i + 1) * binSize).toFixed(2)}`);

                values.forEach(val => {
                    let binIndex = Math.floor((val - minVal) / binSize);
                    if (binIndex >= numBins) binIndex = numBins - 1; // Handle max value edge case
                    bins[binIndex]++;
                });
                data = bins;
                backgroundColor = labels.map(() => `rgba(${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)}, 0.6)`);
            }

            if (myChartInstance) {
                myChartInstance.destroy();
            }

            const ctx = document.getElementById('myChart').getContext('2d');
            myChartInstance = new Chart(ctx, {
                type: chartType === 'histogram' ? 'bar' : chartType,
                data: {
                    labels: labels,
                    datasets: [{
                        label: chartType === 'histogram' ? 'Frequency' : yAxisField || sliceByField,
                        data: data,
                        backgroundColor: backgroundColor,
                        borderColor: backgroundColor.map(color => color.replace('0.6', '1')),
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        async function exportToExcel() {
            if (rawData.length === 0) {
                alert('No data to export. Please upload a file first.');
                return;
            }

            const wb = XLSX.utils.book_new();

            // Original Data Sheet
            const wsData = XLSX.utils.json_to_sheet(rawData);
            XLSX.utils.book_append_sheet(wb, wsData, "Original Data");

            // Pivot Table Sheet
            const pivotTableElement = document.getElementById('pivotTable');
            if (pivotTableElement.rows.length > 0) {
                const wsPivot = XLSX.utils.table_to_sheet(pivotTableElement);
                XLSX.utils.book_append_sheet(wb, wsPivot, "Pivot Analysis");
            }

            // Chart Image Sheet (This is a placeholder, actual image embedding is complex for client-side JS)
            const canvas = document.getElementById('myChart');
            if (canvas && myChartInstance) {
                const imgData = canvas.toDataURL('image/png');
                const wsChart = XLSX.utils.aoa_to_sheet([["Dashboard Chart"]]);
                XLSX.utils.        }
        .main-content {
            flex-grow: 1;
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            min-width: 300px;
        }
        input[type="file"] {
            margin-bottom: 15px;
        }
        button {
            background-color: #007bff;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
        }
        button:hover {
            background-color: #0056b3;
        }
        #pivotTableContainer, #chartContainer {
            margin-top: 20px;
            border: 1px solid #ddd;
            padding: 10px;
            min-height: 200px;
            overflow-x: auto;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        select {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        canvas {
            max-width: 100%;
            height: auto;
        }
        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            .sidebar {
                width: auto;
            }
        }
    </style>
</head>
<body oncontextmenu="return false">
    <header>
        <h1>MyDashboardBuilder</h1>
    </header>
    <div class="container">
        <div class="sidebar">
            <h2>Upload Data</h2>
            <input type="file" id="fileInput" accept=".csv, .xls, .xlsx">
            <button onclick="processFile()">Process File</button>

            <h2>Pivot Analysis</h2>
            <label for="rowField">Rows:</label>
            <select id="rowField"></select>
            <label for="colField">Columns:</label>
            <select id="colField"></select>
            <label for="valueField">Values:</label>
            <select id="valueField"></select>
            <button onclick="generatePivotTable()">Generate Pivot</button>

            <h2>Visualizations</h2>
            <label for="chartType">Chart Type:</label>
            <select id="chartType" onchange="updateChartOptions()">
                <option value="bar">Bar Chart</option>
                <option value="line">Line Chart</option>
                <option value="pie">Pie Chart</option>
                <option value="histogram">Histogram</option>
            </select>
            <div id="chartOptions">
                <label for="chartXAxis">X-Axis:</label>
                <select id="chartXAxis"></select>
                <label for="chartYAxis">Y-Axis:</label>
                <select id="chartYAxis"></select>
            </div>
            <button onclick="generateChart()">Generate Chart</button>
        </div>
        <div class="main-content">
            <h2>Data Preview</h2>
            <div id="dataPreview"></div>

            <h2>Pivot Table</h2>
            <div id="pivotTableContainer"></div>

            <h2>Data Visualization</h2>
            <div id="chartContainer">
                <canvas id="myChart"></canvas>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        document.addEventListener('keydown', function(e) {
            if ((e.ctrlKey && e.key === 'u') || (e.ctrlKey && e.shiftKey && e.key === 'I')) {
                e.preventDefault();
                alert('Access to source code is disabled.');
            }
        });

        let rawData = [];
        let dataHeaders = [];
        let myChartInstance;

        async function processFile() {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];
            if (!file) {
                alert('Please upload a file.');
                return;
            }

            const reader = new FileReader();

            reader.onload = async function(e) {
                const data = e.target.result;
                const fileType = file.name.split('.').pop().toLowerCase();

                if (fileType === 'csv') {
                    PapaParse.parse(data, {
                        header: true,
                        skipEmptyLines: true,
                        complete: function(results) {
                            rawData = results.data;
                            dataHeaders = Object.keys(rawData[0] || {});
                            displayDataPreview();
                            populateSelects();
                        }
                    });
                } else if (fileType === 'xls' || fileType === 'xlsx') {
                    const workbook = XLSX.read(data, { type: 'binary' });
                    const sheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[sheetName];
                    rawData = XLSX.utils.sheet_to_json(worksheet);
                    dataHeaders = Object.keys(rawData[0] || {});
                    displayDataPreview();
                    populateSelects();
                } else {
                    alert('Unsupported file type. Please upload a CSV, XLS, or XLSX file.');
                }
            };
            reader.readAsBinaryString(file);
        }

        function displayDataPreview() {
            const previewContainer = document.getElementById('dataPreview');
            if (!rawData.length) {
                previewContainer.innerHTML = '<p>No data to display.</p>';
                return;
            }

            let html = '<table><thead><tr>';
            dataHeaders.forEach(header => {
                html += `<th>${header}</th>`;
            });
            html += '</tr></thead><tbody>';

            for (let i = 0; i < Math.min(rawData.length, 10); i++) { // Show first 10 rows
                html += '<tr>';
                dataHeaders.forEach(header => {
                    html += `<td>${rawData[i][header] || ''}</td>`;
                });
                html += '</tr>';
            }
            html += '</tbody></table>';
            previewContainer.innerHTML = html;
        }

        function populateSelects() {
            const selects = ['rowField', 'colField', 'valueField', 'chartXAxis', 'chartYAxis'];
            selects.forEach(selectId => {
                const selectElement = document.getElementById(selectId);
                selectElement.innerHTML = '<option value="">--Select--</option>';
                dataHeaders.forEach(header => {
                    const option = document.createElement('option');
                    option.value = header;
                    option.textContent = header;
                    selectElement.appendChild(option);
                });
            });
            updateChartOptions();
        }

        function generatePivotTable() {
            const rowField = document.getElementById('rowField').value;
            const colField = document.getElementById('colField').value;
            const valueField = document.getElementById('valueField').value;
            const pivotContainer = document.getElementById('pivotTableContainer');

            if (!rowField || !valueField) {
                pivotContainer.innerHTML = '<p>Please select at least Row and Value fields for pivot analysis.</p>';
                return;
            }

            const pivotData = {};
            const rowValues = new Set();
            const colValues = new Set();

            rawData.forEach(row => {
                const rVal = row[rowField];
                const cVal = colField ? row[colField] : '_TOTAL_';
                const val = parseFloat(row[valueField]);

                if (isNaN(val)) return;

                rowValues.add(rVal);
                colValues.add(cVal);

                if (!pivotData[rVal]) {
                    pivotData[rVal] = {};
                }
                if (!pivotData[rVal][cVal]) {
                    pivotData[rVal][cVal] = 0;
                }
                pivotData[rVal][cVal] += val;
            });

            const sortedRowValues = Array.from(rowValues).sort();
            const sortedColValues = Array.from(colValues).sort();

            let html = '<table><thead><tr>';
            html += `<th>${rowField}</th>`;
            sortedColValues.forEach(col => {
                html += `<th>${colField ? col : 'Total'}</th>`;
            });
            html += '<th>Grand Total</th>';
            html += '</tr></thead><tbody>';

            let grandColumnTotals = {};
            sortedColValues.forEach(col => grandColumnTotals[col] = 0);
            grandColumnTotals['_TOTAL_'] = 0;

            sortedRowValues.forEach(rVal => {
                html += '<tr>';
                html += `<td>${rVal}</td>`;
                let rowTotal = 0;
                sortedColValues.forEach(cVal => {
                    const value = pivotData[rVal]?.[cVal] || 0;
                    html += `<td>${value.toFixed(2)}</td>`;
                    rowTotal += value;
                    grandColumnTotals[cVal] += value;
                });
                html += `<td>${rowTotal.toFixed(2)}</td>`;
                grandColumnTotals['_TOTAL_'] += rowTotal;
                html += '</tr>';
            });

            html += '<tr><th>Grand Total</th>';
            sortedColValues.forEach(col => {
                html += `<th>${grandColumnTotals[col].toFixed(2)}</th>`;
            });
            html += `<th>${grandColumnTotals['_TOTAL_'].toFixed(2)}</th>`;
            html += '</tr></tbody></table>';
            pivotContainer.innerHTML = html;
        }

        function updateChartOptions() {
            const chartType = document.getElementById('chartType').value;
            const chartOptionsDiv = document.getElementById('chartOptions');
            const chartXAxisSelect = document.getElementById('chartXAxis');
            const chartYAxisSelect = document.getElementById('chartYAxis');

            if (chartType === 'pie') {
                chartXAxisSelect.parentNode.style.display = 'none';
                chartYAxisSelect.labels[0].textContent = 'Values:';
            } else if (chartType === 'histogram') {
                chartXAxisSelect.parentNode.style.display = 'block';
                chartXAxisSelect.labels[0].textContent = 'Bins Field:';
                chartYAxisSelect.parentNode.style.display = 'none';
            }
            else {
                chartXAxisSelect.parentNode.style.display = 'block';
                chartXAxisSelect.labels[0].textContent = 'X-Axis:';
                chartYAxisSelect.parentNode.style.display = 'block';
                chartYAxisSelect.labels[0].textContent = 'Y-Axis:';
            }
        }

        function generateChart() {
            const chartType = document.getElementById('chartType').value;
            const chartXAxisField = document.getElementById('chartXAxis').value;
            const chartYAxisField = document.getElementById('chartYAxis').value;
            const ctx = document.getElementById('myChart').getContext('2d');

            if (myChartInstance) {
                myChartInstance.destroy();
            }

            if (!rawData.length) {
                alert('Please upload data first.');
                return;
            }

            let labels = [];
            let values = [];
            let chartConfig = {};

            if (chartType === 'pie') {
                if (!chartYAxisField) {
                    alert('Please select a value field for the Pie Chart.');
                    return;
                }
                const counts = {};
                rawData.forEach(row => {
                    const val = row[chartYAxisField];
                    counts[val] = (counts[val] || 0) + 1;
                });
                labels = Object.keys(counts);
                values = Object.values(counts);

                chartConfig = {
                    type: 'pie',
                    data: {
                        labels: labels,
                        datasets: [{
                            data: values,
                            backgroundColor: labels.map(() => `hsl(${Math.random() * 360}, 70%, 50%)`),
                            hoverOffset: 4
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: {
                                position: 'top',
                            },
                            title: {
                                display: true,
                                text: `Pie Chart of ${chartYAxisField}`
                            }
                        }
                    }
                };
            } else if (chartType === 'histogram') {
                if (!chartXAxisField) {
                    alert('Please select a field for the Histogram bins.');
                    return;
                }

                const numericData = rawData.map(row => parseFloat(row[chartXAxisField])).filter(val => !isNaN(val));
                if (numericData.length === 0) {
                    alert('No numeric data found for the selected field to create a histogram.');
                    return;
                }

                const minVal = Math.min(...numericData);
                const maxVal = Math.max(...numericData);
                const numBins = 10; // You can make this configurable
                const binWidth = (maxVal - minVal) / numBins;

                const bins = Array(numBins).fill(0);
                const binLabels = [];

                for (let i = 0; i < numBins; i++) {
                    const lowerBound = minVal + i * binWidth;
                    const upperBound = minVal + (i + 1) * binWidth;
                    binLabels.push(`${lowerBound.toFixed(2)}-${upperBound.toFixed(2)}`);
                    numericData.forEach(val => {
                        if (val >= lowerBound && (i === numBins - 1 ? val <= upperBound : val < upperBound)) {
                            bins[i]++;
                        }
                    });
                }
                labels = binLabels;
                values = bins;

                chartConfig = {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: `Frequency of ${chartXAxisField}`,
                            data: values,
                            backgroundColor: 'rgba(54, 162, 235, 0.6)',
                            borderColor: 'rgba(54, 162, 235, 1)',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            title: {
                                display: true,
                                text: `Histogram of ${chartXAxisField}`
                            },
                            legend: {
                                display: false
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: chartXAxisField
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'Frequency'
                                },
                                beginAtZero: true
                            }
                        }
                    }
                };

            } else { // Bar and Line charts
                if (!chartXAxisField || !chartYAxisField) {
                    alert('Please select X-Axis and Y-Axis fields for the chart.');
                    return;
                }

                const groupedData = {};
                rawData.forEach(row => {
                    const xVal = row[chartXAxisField];
                    const yVal = parseFloat(row[chartYAxisField]);
                    if (!isNaN(yVal)) {
                        if (!groupedData[xVal]) {
                            groupedData[xVal] = [];
                        }
                        groupedData[xVal].push(yVal);
                    }
                });

                labels = Object.keys(groupedData).sort();
                values = labels.map(label => {
                    // You might want to sum, average, etc. For simplicity, we'll sum.
                    return groupedData[label].reduce((sum, val) => sum + val, 0);
                });

                chartConfig = {
                    type: chartType,
                    data: {
                        labels: labels,
                        datasets: [{
                            label: `${chartYAxisField} by ${chartXAxisField}`,
                            data: values,
                            backgroundColor: chartType === 'bar' ? 'rgba(75, 192, 192, 0.6)' : 'rgba(75, 192, 192, 0.2)',
                            borderColor: 'rgba(75, 192, 192, 1)',
                            borderWidth: 1,
                            fill: chartType === 'line' ? true : false,
                            tension: chartType === 'line' ? 0.4 : 0
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: {
                                position: 'top',
                            },
                            title: {
                                display: true,
                                text: `${chartType === 'bar' ? 'Bar Chart' : 'Line Chart'} of ${chartYAxisField} by ${chartXAxisField}`
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: chartXAxisField
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: chartYAxisField
                                },
                                beginAtZero: true
                            }
                        }
                    }
                };
            }

            myChartInstance = new Chart(ctx, chartConfig);
        }
    </script>
</body>
</html>
